1.What are the dataTypes in JavaScript and how they differ?
There are eight data types in JavaScript, they are: undefined, null, boolean, number, string, object, symbol, bigInt.
Where Symbol and BigInt are new data types in ES6:
  1.Symbol represents a unique and immutable data type created to resolve possible global variable conflicts.
  2.BigInt is a numeric type of data that can represent integers in any precision format.BigInt can be used to safely store and manipulate     large integers, even if the Number is outside the range of safe integers that number can represent.

2.What's the different between the two data type?
The difference between the two types is the storage location:
  1.The original data type is a simply data segment directly stored in the satck, which occupies a small space and has a fixed size, and       belongs to the frequently used data, so it is strored in the stack.
  2.An object whose data tyoe is stored in the heap, occupying a large space and having an unfixed size. If stored in the stack, it will       affect the performance of the program.The reference data type stores a pointer on the stack that points to the starting address of the     entity in the heap.

2.How to detect data types?
typeof: array, object and null will be judged to be an object.
instanceof: The instanceof operator tests to see if the property of a constructor appears anywhere in the prototype chain of an object.

4.What are the ways to determine an array?
ES6:
```
Array.isArrray(obj)
```
ES5: 
```
Object.prototype.toString.call(obj).slice(8,-1) === 'Array';
obj.__proto__ === Array.prototype;
obj instanceof Array
```

5.The difference between null and undefined?
They are both primitive data type, undefined means there is no defintion, null means an empty object.If you use double equal sign to compare them, it will return true and if you use three equal signto compare them, it will return false.

6.How to realize a instanceof operator?
The instanceof operator is used to detemine whether the constructor's propertype appears anywhere in the object's prototype chain.
```
const myInstanceof = (left, right) => {
  let proto = Object.getPrototypeOf(left)
  let prototype = right.prototype
  while(true) {
    if(!proto) return false
    if (proto === prototype) return true
    proto = Object.getPrototypeOf(proto)
  }
}
```
7.What are the rules for type coercion of the == operator?
For the == operator, if the types of the two operands being compared are different, the type conversion is performed.
First, determine whether the two types are the same, and compare the size of the two if they are the same.
If the types are not the same, type conversion will be performed.
It will first determine whether it is comparing null and undefined, and if it is, it will return true.
Check if the types of both are string and number, if so, the string will be converted to number
If one of the parties is a boolean, if so, it will change the boolean to number and then make the comparision
If one is an object and the other is a string, number or symbol.The object will be converted to its primitive type before the comparison.

8.The difference between Object.is() and the comparison operators '===', '=='?
When using the double equal sign for equality, if the types on both sides are not identical, a cast is performed before the comparison.
When using the third equal sign for equality, if the two types are not the same, the type conversion will not be forced, and will be returned directly.
When using Object.is() to make an equality comparison, it is generally the same as the third equal sign, which deals with some special cases, such as -0 and +0 are no longer equal, and the two NaNs are equal.

9.What's the difference between arrow function and ordinary function?
- The arrow function is simpler:
  1. No arguments can be written directly to empty parentheses
  2. Only one parameter can be omitted from parentheses
  3. Only one sentence of the return value can omit curly braces

- The arrow function doesn't have its own 'this', it only inherits 'this' at the upper level of its scope
- The 'this' pointer inherited by the arrow function never changes
- The arrow function does not have its own arguments; it accesses the arguments value of its outer function
- Arrow functions do not have prototype, Call () , bind () , apply () can not change the 'this' direction of an arrow function

10.What is prototypes and prototype chains?
In JavaScript,almost every objetc has a hidden link to another object.This is so called prototype.
The prototype chain is simply the series of links connecting these objects together.When you try to access a prototype,JavaScript "walks up" the chain until it finds the prototype or reaches the end of the prototype chain.

rewrite and modify prototype
```
function Person(name) {
  this.name = name
}
// modify the prototype
Person.prototype.getName = function () {}
const p = new Person('helo')
console.log(p.__proto__ === Person.prototype) // true
console.log(p.__proto__ === p.constructor.prototype) // true
// rewrite prototype
Person.prototype = {
  getName: function () {}
}
const p = new Person('hello')
console.log(p.__proto__ === Person.prototype) // true
console.log(p.__proto__ === p.constructor.prototype) // false
// turn back
Person.prototype = {
  getName: function () {}
}
const p = new Person('hello')
p.constructor = Person
console.log(p.__proto__ === Person.prototype) // true
console.log(p.__proto__ === p.constructor.prototype) // true

```
- prototype chain pointing
```
p.__proto__ // Person.prototype
Person.prototype.__proto__ // Object.prototype
p.__proto__.__prtto__ // Object.prototype
p.__proto__.constructor.prototype.__proto__ // Obejct.prototype
Person.prototype.constructor.prototype.__proto__ // Object.prototype
p.__proto__.constuctor // Person
Person.prototype.constructor // Person
```

11.Explain 'new' operator in JavaScript. What exactly does it do?
The new operator is used to create an instance object for a given constructor.
- The execution process is like:
  1. Create a new empty object
  2. Sets the prototype of the object to the prototype of the constructor
  3. Let the function's `this` point to the object and add the constructor's properties to the new object
  4. Determines the return type of the function, If it is a value type, return the created object. If it is a reference type, it returns the object of that reference type.

12.The difference between a map and a weakMap?
A Map object is a collection of key/value pairs.
A WeakMap is a collection of key/value pairs whose keys must be objects, with values of any arbitrary.
