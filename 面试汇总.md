#### HTML

##### 1.web worker是干嘛的？

（定义）

Web Worker是一种在浏览器中运行JavaScript代码的机制，可以在主线程之外创建额外的线程来执行任任务。

Web Worker允许将复杂耗时的任务放到后台中执行，避免主线程的阻塞，确保页面的正常交互。

（实现步骤）

1. 创建web worker脚本
2. 在主线程中创建worker
3. 与worker通信
   - `Worker.postMessage()`
   - `Worker.terminate()`

````js
// 创建web worker
const myWorker = new Worker('worker.js');
// 向 Worker 发送消息
myWorker.postMessage(10);

// 接收来自 Worker 的消息
myWorker.onmessage = function(event) {
  console.log('Worker 返回的结果：' + event.data);
};
// 关闭 Worker
myWorker.terminate();
````

（应用场景）

Web Worker适用于一些计算密集型的任务，如图像处理、数据加密等。对于需要处理大规模数据的场景，也使用使用Web Worker并行处理，包括在处理大量网络请求或者下载大文件时，可以将这些任务放在 Web Worker 中执行。

**由于 Web Worker 运行在独立的线程中，并且无法访问 DOM 和 BOM（Browser Object Model），因此无法直接操作 DOM。**

##### 2.如何实现HTML5离线缓存？

（说定义）

离线缓存是指通过web storage或者application cache来在用户离线时存储网络资源，以便用户在离线时仍然能够正常访问这些资源。

（实现步骤）

1. **创建 Manifest 文件：** 创建一个文本文件，文件扩展名为 `.appcache`，在 HTML 页面的 `<html>` 标签中添加 `manifest` 属性

   ````html
   <!DOCTYPE html>
   <html manifest="cache.appcache">
   ````

2. **编辑 Manifest 文件：** 在 Manifest 文件中定义缓存的资源列表

   ````html
   CACHE MANIFEST
   # version 1.0
   
   CACHE:
   index.html
   style.css
   script.js
   image.jpg
   
   NETWORK:
   *
   
   ````

   - `CACHE MANIFEST` 告诉浏览器这是一个 Manifest 文件。
   - `CACHE:` 部分列出了需要缓存的资源。
   - `NETWORK:` 部分列出了需要在线访问的资源。

3. **配置 Web 服务器：** 确保 Web 服务器正确地配置了 MIME 类型，以便识别 `.appcache` 文件

- 如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败
- 在 Manifest 文件中指定的资源不会自动更新，直到 Manifest 文件本身被更新

##### 3.说下常用的drag API

在 Web 开发中，常用的拖放（drag and drop）API 主要是 HTML5 中提供的拖放事件和相关方法。

1. Drag Events（拖放事件）：
   - `dragstart`：当拖动操作开始时触发。
   - `drag`：在拖动操作进行中持续触发。
   - `dragend`：当拖动操作结束时触发。
   - `dragenter`：当拖动对象进入有效的放置目标时触发。
   - `dragover`：当拖动对象在有效的放置目标上移动时触发。
   - `dragleave`：当拖动对象离开有效的放置目标时触发。
   - `drop`：当拖动对象放置到有效的放置目标时触发。事件主体是目标元素。

##### 4.WebSocket是什么？

（说定义）

WebScoket是一种Web中可以实现**双向通信**的技术。它允许浏览器和服务器之间建立持久的、全双工的通信连接，可以实时的发送和接收数据，而无需不断发起Http请求。

- WebSocket基于事件驱动，通过事件监听来处理连接建立，消息发送、接收 ，连接关闭等操作
- WebSocket是一种标准化的协议
- WebSocket 允许在浏览器中跨域建立连接，不受同源政策的限制
- WebSocket还支持加密传输，可以使用 SSL/TLS 来确保通信安全

（应用场景）

WebSocket 可以用于实时聊天应用程序、在线游戏、实时数据展示和监控、实时通知推送等场景。

对比传统轮询（polling）、长轮询（long-polling）的方式WebSocket性能更好，更实时。

轮询的优点在于：

- 兼容性更好
- 易于实现和部署
- 对于服务器的压力更小
- 轮询频率便于调整

**心跳检测**

WebSocket 心跳检测是一种用于保持 WebSocket 连接活跃的机制，通过定期向服务器发送心跳消息，来确认连接的状态。

````js
const socket = new WebSocket('ws://example.com/socket');

// 定义心跳消息内容
const heartbeatMessage = JSON.stringify({ type: 'heartbeat' });

// 定时发送心跳消息
const heartbeatInterval = 30000; // 每 30 秒发送一次心跳消息
let heartbeatTimer;

function sendHeartbeat() {
    if (socket.readyState === WebSocket.OPEN) {
        socket.send(heartbeatMessage);
    }
}

// 监听 WebSocket 连接打开事件
socket.addEventListener('open', () => {
    // 开始定时发送心跳消息
    heartbeatTimer = setInterval(sendHeartbeat, heartbeatInterval);
});

// 监听 WebSocket 接收消息事件
socket.addEventListener('message', (event) => {
    // 如果收到心跳响应消息，可以根据需要进行相应的处理
    if (event.data === heartbeatMessage) {
        console.log('Received heartbeat response');
    } else {
        console.log('Received message:', event.data);
    }
});

// 监听 WebSocket 连接关闭事件
socket.addEventListener('close', () => {
    // 停止定时发送心跳消息
    clearInterval(heartbeatTimer);
    console.log('WebSocket connection closed');
});

// 监听 WebSocket 错误事件
socket.addEventListener('error', (error) => {
    console.error('WebSocket error:', error);
});

````

##### 5.WebRTC的常用API

（定义）

WebRTC可以使网页应用程序在不需要插件和中间服务器的情况下，直接在浏览器之间进行音频、视频、数据传输。

（实现步骤）

1. **获取用户媒体流**：使用 `getUserMedia` API 来获取用户的音频和视频流。这个 API 允许浏览器访问用户的摄像头和麦克风。
2. **建立对等连接**：使用 `RTCPeerConnection` API 来建立对等连接，即客户端之间直接通信的连接。
3. **发送和接收数据：** 一旦连接建立，客户端就可以使用 `send` 和 `onmessage` 方法来发送和接收数据。
4. **处理连接状态：** 客户端可以监听 `onicecandidate` 事件来处理 ICE 候选人，以及监听 `ontrack` 事件来处理远程媒体流的到达等连接状态。

**常用API：**

1. **getUserMedia：** 用于获取用户的媒体流，包括音频和视频。通过调用 `navigator.mediaDevices.getUserMedia()` 方法，可以请求用户授予访问摄像头和麦克风的权限，并获取相应的媒体流。
2. **RTCPeerConnection：** 用于建立对等连接，即在浏览器之间直接进行音视频通信的连接。通过创建 `RTCPeerConnection` 对象，并调用其方法，可以发起连接请求、处理 ICE 候选人、处理远程媒体流等。
3. **RTCDataChannel：** 用于在对等连接上建立双向的、可靠的、低延迟的数据通道，用于传输任意类型的数据。通过调用 `RTCPeerConnection.createDataChannel()` 方法，可以创建数据通道，并在连接上进行数据传输。
4. **RTCSessionDescription：** 用于表示连接的本地描述和远程描述。通过调用 `RTCPeerConnection.setLocalDescription()` 和 `RTCPeerConnection.setRemoteDescription()` 方法，可以设置连接的本地描述和远程描述。
5. **RTCIceCandidate：** 用于表示 ICE（Interactive Connectivity Establishment）候选人，用于协助客户端建立对等连接。通过调用 `RTCPeerConnection.addIceCandidate()` 方法，可以添加 ICE 候选人并进行 ICE 连接建立过程。

（应用场景）

WebRTC用于实现实时的音频和视频通话，包括一对一通话和多方会议通话。远程教学、直播课程、互动答疑等功能。多人在线游戏和虚拟现实应用，支持实时语音聊天、视频聊天、实时位置同步等功能。

##### 6.说下HTML文档的生命周期

（说定义）

HTML文档的生命周期是指从加载到关闭的整个过程，大致会分为4个阶段：

1. **加载阶段**：
   - 浏览器发送请求获取HTML文档
   - 解析HTML文档，构建DOM树
   - 加载外部资源
   - 解析CSS，构建CSSOM树
   - 构建渲染树，即将DOM树和CSSOM树合并，形成渲染树
2. **交互阶段**：
   - 文档加载完成，用户与页面交互
   - 用户通过鼠标、键盘等与页面进行交互
3. **渲染阶段**：
   - 浏览器根据渲染树计算每个节点的样式和位置信息
   - 绘制页面内容，并将其显示在用户界面上
4. **关闭阶段**：
   - 用户关闭或离开当前页面
   - 浏览器销毁页面的DOM、CSSOM和渲染树，释放占用资源

主要事件：

- `DOMContentLoaded` 事件 —— DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口。
- `load` 事件 —— 外部资源已加载完成，样式已被应用，图片大小也已知晓。
- `beforeunload` 事件 —— 用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开。
- `unload` 事件 —— 用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。

#### CSS

##### 1.伪类和伪元素有什么区别？

（说定义）

伪类：是添加到选择器的关键字，用于指定所选元素的特殊状态，修改特殊状态下的样式。

伪元素：是一个附加至选择器末的关键词，允许你对被选择元素的特定部分修改样式。（:: 表示）

伪类的本质还是**类**，作用于标签本身。

伪元素的本质是元素，作用于不存在的虚拟元素中。

##### 2.如何用CSS绘制一个三角形？

1. 利用*border*属性

   - 给定一个宽度和高度都为0的元素，其*border*的任何值会直接相交。利用交点创建三角形，将三边设为透明，仅一边可见。

   ```css
   .border {
       width: 0;
       height: 0;
       border-top: 50px solid pink;
       border-right: 50px solid transparent;
       border-left: 50px solid transparent;
   }
   ```

2. *linear-gradient*

   - 实现一个45度的渐变，渐变颜色固定为两种，把其中一种颜色设为透明。

   ````css
   .triangle{
       width: 100px;
       height: 100px;
       background-color: linear-gredient(45deg, pink 50%, transparent 50%);
   }
   ````

3. 使用*clip-path*

   - *clip-path*属性可以剪裁元素的部分区域进行显示，通过3个坐标点将多余的空间裁剪掉。

   ````css
   .triangle{
   		background-color: red;
   		clip-path: polygon(0 0, 0 100%, 100% 0);
   }
   ````


##### 3.flex： 1 是什么意思？代表了哪些属性？

**flex-grow**： 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大；

**flex-shrink**：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小；

**flex-basis**：给上面两个属性分配多余空间之前，计算项目是否有多余空间，默认值为auto;

flex: 1-- 1 1 0%

flex默认值： 0 1 auto

##### 4. 如何画一个扇形

````css
.div{
  border: 100px solid transparent;
  width: 0;
  height: 0;
  border-radius: 100px;
  border-top-color: red;
}
````

- 使用伪元素和 `transform` 

````css
.fan {
  position: relative;
  width: 100px; /* 扇形的宽度 */
  height: 100px; /* 扇形的高度 */
  border-radius: 50%; /* 圆形 */
  background-color: red; /* 扇形的颜色 */
}

.fan::before {
  content: '';
  position: absolute;
  width: 100%;
  height: 100%;
  background-color: inherit;
  transform-origin: bottom left; /* 以扇形的左下角为旋转中心 */
  transform: rotate(120deg); /* 旋转120度，形成扇形 */
}
````



#### JavaScript

##### 1.描述`<script>`、`<script async>`和`<script defer> `之间的差异

- `<script>`标签是默认的脚本加载方式。当浏览器遇到`<script>`标签时，它会立即加载并执行脚本。这可能会导致页面加载时间过长，因为浏览器必须等待脚本加载和执行完成后才能继续渲染页面。
- `<script async>`标签是异步加载脚本的一种方式。当浏览器遇到`<script async>`标签时，它会立即开始下载脚本，但不会阻止页面的渲染。脚本下载完成后，浏览器会立即执行它。由于脚本的执行顺序与它们被下载的顺序无关，因此它们可能会以任意顺序执行。

- `<script defer>`标签也是异步加载脚本的一种方式。当浏览器遇到`<script defer>`标签时，它会立即开始下载脚本，但不会阻止页面的渲染。脚本下载完成后，浏览器会将它们按照它们在文档中出现的顺序执行。与`<script async>`不同，`<script defer>`保证脚本按照它们在文档中出现的顺序执行。

##### 2.解释原型继承如何工作

（说定义）

原型是 在javascript中，每个对象都有一个私有属性指向另一个叫原型的对象，原型对象也有一个自己的原型，层层向上直到最后一个对象的原型为*null*。*null*没有原型，将它作为原型链的末尾。

这样层层链接的关系叫做原型链。

- 每个实例对象的`_proto_`都是用来它的构造函数的原型对象*prototype*

  `person1._proto_ === Person.prototype`

- 构造函数是一个函数对象，*通过Function*构造器生成

  `Person._proto_ === Function.prototype`

- 原型对象是一个普通对象，*通过Object*构造器生成

  `Person.prototype._proto_ === Object.prototype`

- 所有的构造器是函数对象，均通过*Function*构造器生成

  `Object._proto_ === Function.prototype`

- *Object*的原型对象也有`_proto_`属性，指向***null***即原型链的顶端

  `Object.pertotype._proto_ === null`

​	(说应用)

原型继承是依据原型链实现的一种继承方式。

每个构造函数都会有一个原型对象，而原型对象又会包含一个指向构造函数的指针（*constructor*），构造函数的实例对象会包含一个指向原型对象的指针（`_proto_`）。

​	(缺点)

有多个实例对引用类型的操作会被篡改。

##### 3.var不存在暂时性死区，那如何使用var实现一个暂时性死区？

````js
(function() {
  console.log(typeof myVar); // 输出: undefined
  var myVar = 'Hello, world!';
})();
````

利用闭包在作用域中使用立即执行函数来创建一个新的作用域，并在其中声明变量，从而使变量只在该立即执行函数的范围内有效。

##### 4.Javascript常用的继承方式有哪些？

<img src="/Users/lingziya/Desktop/笔记/继承.jpg" alt="继承" style="zoom:67%;" />

1. 构造函数继承

   **在子类的构造函数中通过call/apply之类的方法调用父类的构造函数--原理在于对this的使用**

   （缺点）

   - 只能继承父类的属性和方法，不能继承父类原型对象的属性和方法。
   - 每次创建子类实例需要重新创建父类的属性和方法。无法实现函数复用。

2. 组合继承

   **借用构造函数来继承属性，原型链来继承方法**

   （缺点）

   - 会调用两次父类构造函数：

     第一次设置子类原型：`SubType.prototype === new SuperType()`，第二次创建子类实例：`SuperType.call(this, argument)`

3. 寄生式继承

   **创建一个实现继承的函数，在函数内部以某种方式增强对象，最后返回该对象**

   ```js
   function newObject(oldObject) {
   	let clone = object(oldObject)
   	clone.newMethod = function() {...}
   	return clone
   }
   ```

     (缺点)

   - 只适用于对象，无法实现函数复用

4. 原型式继承

   **通过object()函数进行浅复制，再将得到的对象实例加以修改**

   `SubType.prototype === Object.create(SuperType.prototype)`

   `Subtype.prototype.constructor === SubType`

     (缺点)

   - 多个实例对引用类型的操作会被篡改

5. 寄生组合式继承（最佳继承方式）

   **寄生式+组合式，解决两次调用父类函数的问题**

   ```js
   let F = function()  //创建一个空构造函数
   F.prototype = SuperType.prototype  //将父类原型复制给空构造函数的原型
   SubType.prototype = new F()  //将子类原型指向空构造函数的实例对象，即该构造函数的原型，即父类的原型
   ```

![js继承](/Users/lingziya/Desktop/学习/js继承.png)

##### 5.说下对this对象的理解

（说定义）

this关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总是指向最后一个调用它的对象。

函数的调用方式会决定this的值：

- 调用函数时使用*new*关键字，此时的*this*指向这个实例对象（new绑定）
- 使用*call()、apply()、bind()*方法调用函数，*this*指向调用这个函数的第一个参数（显式修改）
- 如果函数作为方法被调用，*this*指向这个调用的对象（隐式绑定）
- 在全局环境中调用函数，*this*指向全局对象，在浏览器中是*window*对象，在严格模式下，是*undefined*（默认绑定）

关于优先级：排名靠前的规则优先级更高

若使用箭头函数创建的对象，它不受上述规则影响，*this*指向定义时所在对象所处的环境。

##### 6.apply()、call()、bind()的区别？如何实现一个bind

（说定义）

*apply*以给定的*this*值和参数数组调用函数。

*call*以给定的*this*值和参数调用函数。

*bind*创建一个新函数，以设定的*this*和可以多次传入的参数列表为参数调用函数。

- 三者均可改变函数的*this*对象指向
- 当第一个参数为undefined｜null ｜空时，默认指向全局window
- *apply*传入参数数组，*call*传入参数列表，*apply*和*call*一次性传入参数，*bind*可以多次传入参数
- *bind*返回绑定*this*之后的函数，*apply*、*call*立即执行

*bind* 实现步骤：

1. 修改*this*指向
2. 动态传递参数
3. 兼容*new*关键字

```js
Function.prototype.myBind = function(context) {
	if(typeof this !== 'function') {
		throw new TypeError("Error!")
	}
  const args = [...arguments].slice(1)
  const fn = this
  return function res = function() {
  	const resArg = [...arguments]
  	if(this instanceof res) {	
 	 		fn.apply(this, args.concat(resArg))
  	} else {
  		fn.apply(context, args.concat(resArg))
  	}
  }
  res.prototype = Object.create(fn.prototype)
  return res
}
```

##### 7.说下对闭包的理解？闭包的使用场景？

（说定义）

闭包是，当通过调用一个外部函数返回一个内部函数后，即使外部函数已结束执行，但内部函数饮用外部函数的**变量**依然存在内存中，闭包是这些变量的集合。

<!--在函数A中还有函数B，函数B调用了函数A中的变量，函数B称为函数A的闭包-->

（好处）

- 缓存。将变量隐藏起来不被GC回收
- 实现柯里化。利用闭包特性实现柯里化

（缺点）

- 内存消耗。闭包产生的变量无法被主动销毁
- 影响性能。闭包内部变量优先级高于外部变量，查找时需要多查找一层作用域链。

（场景）

计数器、延迟调用、回调

##### 8.什么是事件循环？

（说定义）

*Javascript*从*script*开始读取，然后不断循环，从任务队列中读取执行事件的过程就是事件循环。

（执行顺序）

1. 从整个脚本*script*作为一个**宏任务**执行开始
2. 执行过程中，**同步代码**直接执行，**宏任务**进入宏任务队列，**微任务**进入微任务队列
3. 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完毕
4. 执行浏览器*UI*线程渲染任务
5. 检查是否有*Web* *Worker*任务，有则执行
6. 执行完本轮的宏任务回到步骤2，依次循环

宏任务队列（*MacroTask*）可以有多个，微任务队列（*MicroTask*）只有一个。

常见的宏任务：

- *script*
- *setTimeout* / *setInterval*
- *UI* *rendering*
- *setImmediate*
- *I/O  (Node.js)*

常见的微任务：

- *Promise.then / catch*
- *Mutation Observer*
- *process.nextTick (Node.js)*
- V8的垃圾回收过程

***async*与*await*对事件循环的影响**

*async*函数返回一个*Promise*对象，*await*会阻塞下面的代码（加入微任务队列）

##### 9.说下对Promise的理解？

（说定义）

Promise是为了解决回调地狱而提出的一种异步方案。

*Promise*的三种状态：

- 初始状态：*pending*
- 成功状态：*fulfilled*
- 失败状态：*rejected*

***Promise*的状态一经改变就不能再改变。**

*Promise*的常用方法：

- *all()*: 接受多个*Promise*实例，返回一个新的*Promise*，只有当所有实例状态都*fulfilled*，返回的Promise才会改变状态为*fulfilled*。
- *race()*：接受多个*Promise*实例，返回一个新的*Promise*，返回值会随第一个改变的实例状态而改变状态。
- *allSettled()*：接受一组*Promise*实例，返回一个新的*Promise*，只有所有都 实例返回结果，不管是*fulfilled*还是*rejected*，返回带有每个*Promise*结果的对象数组。

（应用场景）

将图片的加载写成一个*Promise*，一旦加载完成，*Promise*的状态就发生变化。

**手写*Promise***

##### 10.new操作符做了什么？

（说定义）

*new*运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。

（实现步骤）

1. 创建一个空的*javascript*对象，称为*newInstance*
2. 如果构造函数的*prototype*属性是一个对象，就将*newInstance*的[[*Prototype*]]指向构造函数的这个属性，否则[[*Prototype*]]为*Object.prototype*
3. 将构建函数的*this*绑定到*newInstance*上
4. 根据构造函数返回类型作判断，如果是原始值则忽略，如果是返回对象，则该返回值称为整个*new*表达式的结果

（手写）

- 第一个参数必须是个函数

```js
function mynew(Func, ...args) {
    // 1.创建一个新对象
    const obj = {}
    // 2.新对象原型指向构造函数原型对象
    obj.__proto__ = Func.prototype
    // 3.将构建函数的this指向新对象
    let result = Func.apply(obj, args)
    // 4.根据返回值判断
    return result instanceof Object ? result : obj
}
```

##### 11.typeof 和 instanceof 的区别

（说定义）

*typeof* 运算符返回一个字符串，表示操作数的类型。

```js
typeof 1 // 'number'
typeof '1' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'
typeof null // 'object'
typeof [] // 'object'
typeof {} // 'object'
typeof console // 'object'
typeof console.log // 'function'
```

**基础类型除了*null*之外，均会正常检测出其类型，引用类型除了函数会检测为*function*，其余的都检测为*object*。**

*instanceof* 运算符用于检测构造函数的 *prototype* 属性是否出现在某个实例对象的原型链上。

```js
object instanceof constructor
// 定义构建函数
let Car = function() {}
let benz = new Car()
benz instanceof Car // true
let car = new String('xxx')
car instanceof String // true
let str = 'xxx'
str instanceof String // false
```

***instanceof* 的实现原理：顺着原型链找，直到找到相同的原型对象，返回*true*，否则返回 *false* 。**

```js
function myInstanceof(left, right) {
  //使用 typeof 判断基础数据类型，对于基础类型数据直接返回false
  if(typeof left !== 'object' || left === null) return false
  //使用Object对象自带的API,可以获取到参数的原型对象
  let proto = Object.getPrototypeOf(left)
  while(true) {
    if(proto === null) return false
    if(proto === right.prototype) return true //存在相同原型对象，返回true
    proto = Object.getPrototypeOf(proto)
  }
}
```

（缺点）

- *instanceof*可以准确判断引用数据类型，但对于基础数据类型不能准确判断
- *typeof*则对除了*function*类型的引用类型数据无法准确判断

（更优解）

**采用*Object.prototype.toString()*，统一返回 [*object Xxx*] 格式字符串**

```js
Object.prototype.toString({})       // "[object Object]"
Object.prototype.toString.call({})  // 同上结果，加上call也ok
Object.prototype.toString.call(1)    // "[object Number]"
Object.prototype.toString.call('1')  // "[object String]"
Object.prototype.toString.call(true)  // "[object Boolean]"
Object.prototype.toString.call(function(){})  // "[object Function]"
Object.prototype.toString.call(null)   //"[object Null]"
Object.prototype.toString.call(undefined) //"[object Undefined]"
Object.prototype.toString.call(/123/g)    //"[object RegExp]"
Object.prototype.toString.call(new Date()) //"[object Date]"
Object.prototype.toString.call([])       //"[object Array]"
Object.prototype.toString.call(document)  //"[object HTMLDocument]"
Object.prototype.toString.call(window)   //"[object Window]"
```

基于*toString*实现全局通用的数据类型判断方法：

```js
function getType(obj){
  let type  = typeof obj;
  if (type !== "object") {    // 先进行typeof判断，如果是基础数据类型，直接返回
    return type;
  }
  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果
  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, '$1'); 
}
```

##### 12.数组去重的方法？

- *for*循环截取

```javascript
const arr = [1,1,2,2,3,4,5] //原始数组
const newArr = [] //去重后数组
for(let i = 0; i < arr.length; i++) {
  if(!newArr.includes(arr[i])) {
    newArr.push(arr[i])
  }
}
return newArr;
```

- *ES6*中的*Set*

```js
const arr = [1,1,2,2,3,4,5] //原始数组
//Set对象允许你存储任何类型的唯一值
const newArr = [...new Set(arr)] 
return newArr
```

- *filter*过滤

```js
const arr = [1,1,2,2,3,4,5] //原始数组
const newArr = arr.filter((item, index) => {
  arr.indexOf(item) == index
})
return newArr
```

- *Map*数据结构特点

```js
const arr = [1,1,2,2,3,4,5] //原始数组
const map = new Map()
cosnt newArr = []
arr.forEach((item) => {
  if(map.has(item)) {
    map.set(item, true)
  } else {
    map.set(item, false)
    newArr.push(item)
  }
})
return newArr
```

##### 13.如何实现防抖与节流？

（说定义）

防抖：事件在n秒后执行，若在n秒内被重复触发，则重新执行。

节流：事件在n秒内只执行一次，若在n秒内重复触发，则只执行一次。

- 实现一个防抖：
  1. 设置一个定时器
  2. 设置一个闭包，返回一个方法
  3. 若反复进来，则清空定时器，重新设置前面步骤

```javascript
function debounce(fn, wait, immediate) {
  let timer = null 
  let isImmediate = false
  
  return function() {
    let args = arguments
    if(timer) clearTimeout(timer)
    if(immediate && !isImmediate) {
      fn.bind(this, args)
      isImmediate = true
    }
    timer = setTimeout(function() {
      fn.bind(this, args)
      isImmediate = false
    }, wait)
  }
}
```

- 实现一个节流：
  1. 设置一个标记
  1. 设置一个闭包，返回一个方法
  1. 若重复进入的时候，标记已经改变，则继续执行
  1. 若计时器执行完，设置标记不变，允许下一次执行


```js
function throttle(fn, wait) {
  let timer = null
  let startTime = 0
  return function(...args) {
    const curTime = new Date().getTime()
    const remainTime = wait - (curTime - startTime)
    if(remainTime <= 0) {
      fn.bind(this, args)
      startTime = curTime
    } else {
      timer = setTimeout(fn, remainTime)
    }
  }
}
```

（应用场景）

防抖：

- 搜索框输入。用户最后一次输入完再发送请求。
- 监听用户缩放浏览器resize。窗口调整完成后再计算大小。
- 监听浏览器滚动事件。

节流：

- 滚动加载。加载更多。
- 搜索联想功能。

##### 14.从输入URL到页面呈现发生了什么？

（说定义）

1. *DNS* 解析
2. *TCP* 连接
3. 发送 HTTP 请求
4. 服务器响应
5. 浏览器解析渲染页面

**DNS解析过程**

通过网络查找哪台服务器有所需资源的过程。

**TCP连接**

1. 建立客户端和服务端的连接。**三次握手**。
2. 传输数据。
3. 断开客户端和服务端的连接。**四次挥手**。

**HTTP请求**

构建HTTP请求报文，通过TCP协议发送到服务器指定端口。

（注意）**HTTP请求会涉及到[跨域问题]()**

**服务器响应**

服务器处理完请求后，返回HTTP响应报文（**状态码**+响应报头+响应报文）。

**浏览器渲染过程**

![浏览器渲染过程](/Users/lingziya/Desktop/学习/数据结构/浏览器渲染过程.png)

1. 解析*HTML*，生成*DOM*树
2. 解析*CSS*，生成*CSS*规则树（CSS Rule Tree）
3. *DOM*树和*CSS*规则树结合，生成渲染树（Render Tree）
4. 从根节点开始，计算每一个元素的大小、位置，得到布局渲染树（Layout render tree）
5. 遍历渲染树，*UI*渲染引擎将整柯树绘制到页面上，绘制渲染树（Painting the render tree）

渲染过程可能产生**重绘**和**回流**

- 重绘：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新。
- 回流：当元素的尺寸、结构或者触发某些属性时，浏览器会重新渲染页面。

**回流一定会触发重绘**

引起回流的行为：

- 添加或删除可见的DOM元素
- 元素的位置发生变化
- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代
- 页面一开始渲染的时候（这避免不了）
- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

引起重绘的行为：

- 元素颜色的修改
- 文本方向的修改
- 阴影的修改

##### 15.说下浏览器的缓存机制

（说定义）

缓存过程：

1. 浏览器第一次发起*HTTP*请求
2. 浏览器缓存返回浏览器目前浏览器没有该请求的**缓存结果**和**缓存标识**
3. 浏览器向服务器第二次发起*HTTP*请求
4. 服务器返回该请求结果和缓存规则
5. 浏览器将该请求结果和缓存标识存入浏览器缓存中

创建的缓存机制分为**强缓存**和**协商缓存**，通过设置*HTTP header*实现。

- 强缓存：不会向服务器发送请求，直接从浏览器缓存中读取资源。

（实现方式）

1. *Expires*：指定缓存过期的时间。在过期时间前浏览器可以直接从缓存取数据，无需再次请求。
2. *Cache-Control*：通过指定指令来实现缓存机制。

```javascript
Cache-control: no-cache  //客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定
Cache-control: no-store  //所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
Cache-control: public  //表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存
Cache-control: private  //表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）
Cache-Control: max-age=<seconds>  //表示缓存内容将在xxx秒后失效
Cache-control: s-maxage=<seconds>  //覆盖max-age或者Expires头，但是仅适用于共享缓存
```

强缓存判断是否缓存的依据来自于资源是否超出某个时间或者某个时间段，并不验证服务端资源是否更新，因而可能导致加载的资源不是服务端最新的内容。

***Cache-Control*优先级高于*Expires*。**

- 协商缓存：强制缓存失效后，浏览器携带缓存标识向服务器发起请求，服务器根据缓存标识决定是否使用缓存。
  1. 协商缓存生效。返回**304**和***Not Modified***
  2. 协商缓存失败。返回**200**和此次**请求结果**

（实现方式）

1. *If-Modified-Since*（请求）+  *Last-Modified*（响应）：
   1. 浏览器发送第一次请求，服务器在响应头中返回资源做出修改的时间和日期即：*Last-Modified*，浏览器收到后缓存该时间
   2. 浏览器发起第二次请求，请求头*If-Modified-Since*，若服务器资源修改时间和浏览器保存的时间一致，则返回没有消息主体的 304 *Not Modified*，若资源在给定时间后有修改，则返回 200 和最新的资源。
2. *If-Match*（请求）+ *ETag* （响应）：
   - *ETag*是资源的唯一标识符，一旦资源发生更改，则需要生成新的*ETag*值，通过与包含*ETag*值的*If-Match*请求头对比来检查资源是否为最新版本。

- 精确度上：*Etag*要优于*Last-Modified*
- 优先级上：服务器校验优先考虑*Etag*
- 性能上：*Etag*要逊于*Last-Modified*

##### 16.[实现跨域的方法]()

（说定义）

**同源策略**：是指*URL*中 3 个（协议、域名、端口）一致的情况下，才属于同源。

两个页面对应的地址不同**源**，则认为是跨域：

- *Ajax*请求无法发送
- 无法获取*DOM*元素并进行操作
- 无法读取*Cookie*、*LocalStorage*、*IndexDB*

（解决方法）

**JSONP**

利用 `<script>` 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的*JSON*数据。*JSONP*请求一定需要对方的服务器做支持才可以：

1. 在前端定义解析函数*callback=function(){..}*
2. 动态创建`<script>`标签，将`src`属性指向跨域的接口，将解析函数作为请求的参数
3. 后端收到该解析函数后，带上参数并调用执行函数的方式返回给前端一个*javascript*脚本

```javascript
// 1. 创建解析函数callback
function myCallback(res) {
    alert(JSON.stringify(res, null , 2));
}
document.getElementById('btn-4').addEventListener('click', function() {
    // 2. 动态创建script标签，并设置src属性，注意参数cb=myCallback
    var script = document.createElement('script');
    script.src = 'http://127.0.0.1:3000/info/jsonp?cb=myCallback';
    document.getElementsByTagName('head')[0].appendChild(script);
});
```

```javascript
router.get('/jsonp', (req, res, next) => {
    var str = JSON.stringify(data);
    // 3. 创建script脚本内容，用`callback`函数包裹住数据
    // 形式：callback(data)
    var script = `${req.query.cb}(${str})`;
    res.send(script);
});
// 4. 前端收到响应数据会自动执行该脚本
```

- 优点：兼容性好
- 缺点：仅支持*get*请求

**CORS**

跨域资源共享是一种基于*HTTP*头的机制，它允许服务器向跨源服务器，发出 *XMLHttpRequest* 或 *Fetch* 请求。

- 简单请求：不会触发*CROS*的预检请求
  - 简单请求 的发送从代码上看起来和普通的 XHR 没太大区别，但是 HTTP 头当中要求总是包含一个域（Origin）的信息。该域包含协议名、地址以及一个可选的端口。

- 预检请求：不满足简单请求情况的请求
  - 不止发送一个请求。其中最先发送的是一种 “预请求”，而服务端也需要返回 “预回应” 作为相应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。

**Nginx反向代理**

*Nginx* 则是通过配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。

配置*nginx*：

```javascript
// proxy服务器
server {
    listen 80;
    server_name  www.domain1.com;
    location /api {
        proxy_pass   http://www.domain2.com:8080;  #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;

        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}
```

**Node代理**

同源政策是浏览器需要遵循的标准，服务器之间的请求不会跨域。

利用*Node*中间件代理（2次跨域）：

1. 接受客户端请求
2. 将请求转发给服务器
3. 获取服务器响应数据
4. 将响应数据转发给客户端

![node代理](/Users/lingziya/Desktop/学习/数据结构/node代理.jpeg)

**postMessage**

*window.postMessage()* 方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。

（应用场景）：

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的iframe消息传递
- 上面三个场景的跨域数据传递

**Websocket**

*WebSockets*定义了一种API，可以实现客户端和服务端之间持久的连接，且双方可以随时发送消息并获得响应数据。

常用的是封装了*WebSocket*接口的第三方工具*Socket.io*，对不支持*WebSocket*的浏览器提供了向下兼容。

```html
<script>  
  let socket = new WebSocket("ws://localhost:3000");  
	socket.onopen = function() {    
    socket.send("连一下");  //向服务器发送数据
  };  
	socket.onmessage = function(e) {    
    console.log(e.data);  //接受服务器返回的数据
  };
</script>
```

```js
// server.js
const WebSocket = require('ws');//记得安装ws
const server = new WebSocket.Server({port:3000});
server.on('connection',function(ws) {
  ws.on('message', function (data) {
    console.log(data);
    ws.send('说下暗号')
  });
})
```

##### 17.JS中的垃圾回收机制是怎样的？

（说定义）

*JS*执行自动的垃圾收集机制，垃圾收集器每隔一段时间就执行一次释放操作，清理垃圾数据，释放内存。

**内存模型**

- 栈内存：*JS*中的基础数据类型，这些值都有固定的大小，往往都保存在栈内存中（闭包除外），由系统自动分配存储空间。
- 堆内存：引用数据类型的值是保存在堆内存中的对象。*JS*不允许直接访问堆内存中的位置，因此在操作对象时，实际上是在操作对象的引用而不是实际的对象。

**局部变量和全局变量的销毁**

- 局部变量：局部作用域中，当函数执行完毕，局部变量就没有存在的必要了，因此垃圾收集器很容易判断并回收
- 全局变量：全局变量什么时候需要自动释放内存空间很难判断，因此应尽量避免使用全局变量

***V8*引擎中，*JS*对象都是通过堆进行内存分配的**

- 初始分配：一旦声明变量并赋值，*V8*引擎就会在**堆**内存中分配空间给这个变量
- 继续申请：当已申请的内容不足以存储这个变量时，*V8*引擎就会继续申请内存，直到达到了**堆**内存的上限为止

***V8*引擎对堆内存中的*JS*对象实行分代管理**

- 新生代：存活周期较短的*JS*对象，如临时变量、字符串等
- 老生代：经过多次垃圾回收仍然存活，存在周期较长的对象，如主控制器、服务器对象等

**垃圾回收算法**

- 标记清除算法：
  - 从根部（在*JS*中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象保留。那些从根部出发无法触及到的对象被标记为**不再使用**，稍后进行回收。
  - 对一块内存多次执行标记 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存。
- 标记整理算法；
  - 从根部出发扫描内存中的对象，凡是能从根部到达的对象标记为活动对象。
  - 让所有存活的对象向内存的一段移动。

**内存泄漏**

对于不再用到的内存，没有及时释放，就叫做内存泄漏。

- 常见的内存泄漏：

  - 意外的全局变量：未定义的变量会在全局对象创建一个新变量。

  ```js
  function foo() {
      this.variable = "potential accidental global";
  }
  // Foo 调用自己，this 指向了全局对象（window）
  // 而不是 undefined
  foo();
  ```

  - （解决方案）
    1. 在 *JavaScript* 文件头部加上 `'use strict'`，使用严格模式避免意外的全局变量。
    2. 如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 *null* 或者重新定义。

  - 被遗忘的计时器或回调函数
  - 脱离*DOM*的引用
  - 闭包

##### 18.浏览器有哪些进程和线程？

（说定义）

进程：进程是*CPU*资源分配的最小单位。（能拥有资源和独立运行的最小单位）

线程： 线程是*CPU*资源调度的最小单位。（线程是进程上的一次程序运行单位，一个进程可以有多个线程）

现代浏览器的主要进程：

1. *Browser*进程（主进程）
   - 控制*chrome*的地址栏、书签栏，前进和后退按钮，网络资源管理下载和文件访问等
2. 第三方插件进程：
   - 每种类型的插件对应一个进程，仅当使用该插件时才创建
3. *GPU*进程：
   - 仅此一个，用于*3D*绘制
4. 浏览器渲染进程（**浏览器内核**）：
   - （内部是**多线程**的）负责页面渲染、脚本执行、事件处理等

**在浏览器内打开一个网页相当于新起了一个进程，进程内有自己的多线程**

**多进程**浏览器的优势：

1. 避免单个页面崩溃导致的浏览器卡顿
2. 避免第三方插件的崩溃影响整个浏览器
3. 多进程充分利用多核优势
4. 方便使用沙盒模式隔离插件等进程，提升浏览器稳定性

**多线程的浏览器内核**：

1. *GUI*渲染线程

   - 负责渲染浏览器页面，解析*HTML*、*CSS*，构建*DOM*树和*Render*树，布局和绘制等。
   - 当页面需要**重绘**或由于某种操作引起**回流**时，该线程执行。

   ***GUI*线程和*JS*线程是互斥的，当*JS*线程执行时*GUI*线程会被挂起，*GUI*更新会被保存在一个队列中等*JS*引擎空闲时再执行**

2. *JS*引擎线程

   - 也称作*JS*内核，负责解析、执行*JavaScript*脚本。
   - *JS*引擎一直等待任务队列中的任务到来，然后处理。一个*Tab*页中始终只有一个*JS*线程在运行*JS*程序。

   **由于*GUI*线程和*JS*线程是互斥的，长时间的*JS*执行会导致页面渲染加载阻塞**

   关于*GUI*线程和*JS*线程互斥的原因，是因为*JavaScript*是可操作*DOM*的，如果在修改元素的同时渲染页面，渲染前后获得的元素属性可能会不一致。

3. 事件触发线程

   - 归属于浏览器而非*JS*引擎，主要用于控制事件循环。
   - 当*JS*执行代码块如*setTimeout*（或者是浏览器内核的其他线程，如**鼠标点击**、***AJAX*异步请求**等），会将该任务加入到事件触发线程中。
   - 当对应事件满足条件被触发时，该线程会将事件添加到（**宏任务**）任务队列的队尾，等待*JS*引擎空闲后处理。

4. 定时器触发线程

   - 浏览器定时器不由*JS*引擎计时（因为*JS*引擎是单线程，在阻塞状态会影响计时准确性）
   - 通过单独的线程来计时和触发定时（计时完毕后，添加到**宏任务**任务队列队尾，等待*JS*引擎空闲后处理）

   在W3C在HTML标准中规定，规定要求*setTimeout*中低于4ms的时间间隔算为4ms。

5. 异步*http*请求线程

   - *XMLHttpRequest*在连接后会通过浏览器新开一个线程请求。
   - 当检测到状态更新时，如果有回调函数，该线程就产生**状态变更事件**，将回调函数放入（**微任务**）事件队列，等待*JS*引擎执行。

***Browser*进程和浏览器内核的通信过程**：

1. ***Browser*进程**接收用户请求，首先获取页面内容，然后将任务通过*RendererHost*接口传递给渲染进程
2. 渲染进程的*Renderer*接口收到消息后，简单解释并交给***GUI*渲染线程**，由该线程执行页面渲染：
   1. 渲染线程接收请求，加载并渲染页面，这个过程可能需要**主进程**和***GPU*进程**获取资源来帮助渲染
   2. 可能会有***JS*引擎线程**执行*DOM*操作（导致回流或重绘）
   3. ***Render*进程**将结果传递给***Browser*进程**
3. ***Browser*进程**接收到结果并将结果绘制出来

##### 19.有哪些性能优化的手段？

从浏览器页面响应渲染的过程细分每一步的优化手段

***HTTP*请求阶段可做优化**：

1. 浏览器缓存：通过使用强缓存或者是协商缓存，可以实现有缓存页面的快速加载
2. 利用*Cookie*和*WebStorage*对部分数据进行缓存
3. 静态资源的请求可以使用*CDN*，减少服务器压力
4. 利用负载均衡特性，开启*Node.js*的*PM2*或者是*Nginx*的反向代理，轮询服务器，平均各个服务器的压力

**服务器响应阶段优化手段：**

1. *Webpack*：发布项目前，利用可视化插件分析，使用*Happypack*工具提高打包效率，项目内容进行按需加载，*tree shaking*
2. 图片优化：根据图片属性特点，利用*Webpack*的*url-loader*将小图标转化成*Base*64格式，对于*icon*使用*Svg*格式，对于一些轮播图、*Banner*图使用*Jpg、Jpge*格式，使用雪碧图
3. *G-zip*压缩：在文本文件中查找重复的字符串，临时替换， 利用*Webpack* 的 *ComparessionPlugin*进行 *Gzip* 压缩，然后在 *Nginx* 上进行配置
4. 服务端渲染（*SSR*）：在浏览器请求的时候，服务端将已经渲染好的*HTML*页面直接返回给浏览器，浏览器直接加载*HTML*渲染即可，减少了前后端交互，对*SEO*更友好

**浏览器解析渲染页面阶段优化手段：**

1. 尽可能少使用*CSS*选择器选择元素
2. 在*head*为止加载*CSS*，减少*HTML*加载完需要等待CSS加载的问题
3. 将*script*标签放在*body*后，利用*async*和*defer*属性，异步加载*JS*
4. 避免在*DOM*渲染的时候触发回流和重绘

**其他手段：**

1. *Chorme*插件可视化判断页面可优化部分
2. 长列表使用懒加载
3. *preload*预加载页面

***Webpack*优化手段：**

1. *JS*代码压缩：*terser*
1. *CSS*代码压缩：*css-minimizer-webpack-plugin*
1. *HTML*文件代码压缩：*HtmlWebpackPlugin*插件配置属性*minify*优化
1. 图片压缩
5. *Tree Shaking*：
   1. *usedExports*：通过标记某些函数是否被使用，之后通过*Terser*来进行优化
   2. *sideEffects*：跳过整个模块/文件，直接查看该文件是否有副作用
   3. *PurgeCss*：对*CSS*进行*tree shaking*
6. 代码分离：通过*splitChunksPlugin*实现分离出更小的*bundle*

##### 20.如何修改原型链？

1. 使用 `Object.setPrototypeOf()` 方法来动态地修改对象的原型链。

   ````js
   function Person(name) {
     this.name = name;
   }
   Person.prototype.sayHello = function() {
     console.log('Hello, ' + this.name);
   };
   var person1 = new Person('Alice');
   // 修改原型链
   var newProto = {
     sayHello: function() {
       console.log('Hola, ' + this.name);
     }
   };
   Object.setPrototypeOf(person1, newProto);
   ````

2. 使用 `Object.create()` 方法创建一个新对象，并指定其原型对象。这种方式可以在创建对象时直接设置原型链。

   ````js
   var personProto = {
     sayHello: function() {
       console.log('Hello, ' + this.name);
     }
   };
   var person1 = Object.create(personProto);
   person1.name = 'Alice';
   var person2 = Object.create(personProto);
   person2.name = 'Bob';
   var newProto = {
     sayHello: function() {
       console.log('Hola, ' + this.name);
     }
   };
   // 修改原型链
   Object.setPrototypeOf(personProto, newProto);
   ````

##### 21.**ES6**模块与**CommonJS**模块有什么异同？ 

1. **语法**：
   - **ES6模块**：使用`import`和`export`关键字来导入和导出模块。
   - **CommonJS模块**：使用`require()`函数来导入模块，使用`module.exports`或`exports`对象来导出模块。
2. **编译时 vs 运行时**：
   - **ES6模块**：在编译时静态解析模块依赖关系，使得在模块加载时能够进行更好的优化。
   - **CommonJS模块**：在运行时动态加载模块，因此可能会导致性能损失。
3. **浏览器支持**：
   - **ES6模块**：现代浏览器原生支持。
   - **CommonJS模块**：通常需要使用工具（如Webpack、Browserify等）来将其转换为浏览器可执行的代码。
4. **循环依赖处理**：
   - **ES6模块**：能够处理循环依赖，但导入的值是动态绑定的。
   - **CommonJS模块**：可以处理循环依赖，并且导出的值是实时的。

运行时加载（Runtime Loading）和编译时加载（Compile Time Loading）是两种不同的加载方式，它们的主要区别在于加载发生的时间点和加载对象的类型。

1. **编译时加载（Compile Time Loading）：**
   - 加载发生在代码编译阶段，即在源代码被编译成目标代码之前。
   - 加载的对象是静态的，通常是模块、库或者依赖项。
   - 编译时加载的优点是能够在编译阶段进行静态检查，减少运行时的错误，提高代码的可靠性和性能。
   - 但缺点是可能会增加程序的启动时间，尤其是在加载大量模块或依赖项时。
2. **运行时加载（Runtime Loading）：**
   - 加载发生在程序运行时，即在目标代码被执行的过程中。
   - 加载的对象是动态的，通常是根据运行时的条件或需求来决定加载的。
   - 运行时加载的优点是能够根据需要动态加载模块或依赖项，节省资源并提高程序的灵活性。
   - 但缺点是可能会导致代码的可维护性下降，因为一些依赖关系只有在运行时才能确定。

总的来说，编译时加载更适合静态和稳定的模块或库，能够在编译阶段进行优化和静态检查；而运行时加载更适合动态和可变的情况，能够根据运行时的需求来动态加载模块或依赖项。选择哪种加载方式取决于具体的需求和场景。

##### 22.数据类型检测的方法有哪些？

1. typeof（）: 检测object、array、null都被判断为object，基础数据类型检测均正确
2. instanceof（）：根据**在被检测对象原型链中能否找到原型**进行类型判断，可以正确判断引用类型，不能判断基本数据类型。同时可用于测试一个对象在其原型链中是否存在一个构造函数的`prototype`属性
3. constructor：判断数据类型，对象实例通过`constructor`访问它的构造函数

##### 23.判断数组的方法有哪些？

1. `Object.prototype.toString.call(obj) === Array`
2. 原型链判断：`obj.__proto__ === Array.prototype`
3. ES6: `Array.isArray(obj)`
4. `obj instanceof Array`
5. `Array.prototype.isPrototypeOf(obj)`

**`isPrototypeOf` 用于检查原型链中的关系，而 `instanceof` 用于检查构造函数和实例之间的关系。**

##### 26. isNaN 和 Number.isNaN 函数的区别？

两者都可用于检测一个值是否为NaN。

- `isNaN()`	会将其转换为数值，然后再检查是否为 NaN。如果传入的值是 NaN、字符串不是数字、或者是对象，返回 `true`；否则返回 `false`。

- `Number.isNaN()` 只在传入值为真正的 NaN 时返回 `true`，对于其他值都返回 `false`。不会进行类型转换，只有在值严格等于 NaN 时才返回 `true`，否则返回 `false`。

推荐使用 `Number.isNaN()` 来进行 NaN 的判断，因为它更加准确。

##### 27. Object.is() 与比较操作符 “===”、“==” 的区别？

`Object.is()`进行判断时，一般情况与`===`判断相等，会处理一些特殊情况：

- `Object.is(NaN, NaN) // true`   vs  `NaN === NaN; //false`
- `Object.is(0, -0); //false`  vs  `0 === -0; //true`

##### 28. 数组的原生方法

##### 29. 哪些方法可以将类数组转为数组？

##### 30. 说下作用域和作用域链

在javascript中，作用域指的是变量和函数的可访问性和可见性。主要有以下三种类型：

1. 全局作用域：

   全局作用域即是javascript程序最外层的作用域，在该作用域中声明的函数和变量可以在程序的任何地方被访问

2. 函数作用域：

   函数作用域是在函数体内部声明的作用域，函数内部声明的变量只能在函数内部被访问，外部不行

3. 块级作用域（ES6）：

   ES6新增的let和const可以声明块级作用域，是由`{}`包裹的代码块创建的作用域，只能在该代码块内部被访问

作用域链是当前执行上下文中的所有可访问的变量对象形成的一个链式结构。在当前作用域中查找不到所需变量时，就到该变量的父级作用域中查找，依次向上级作用域查找，直至window对象。

##### 31. 说下事件流

事件流是指事件在DOM树中的传播过程。当事件在目标DOM元素上触发时，会经历**事件捕获**、**目标事件**、**事件冒泡**三个阶段。

1. **捕获阶段**： `addEventListener(type, listener, true);`

   在该阶段，事件从外层元素向内层元素传播，直到抵达目标元素

2. **目标阶段**

   事件达到目标元素，并在目标元素上触发相应的事件回调函数

3. **冒泡阶段**：`addEventListener(type, listener, false);`

   在该阶段，事件从内层元素向外层元素传播，直到抵达根元素

在javascript，可以通过`addEventListener()`注册事件处理函数，从而控制事件在事件流中的传播行为。

##### 32. 解释下垃圾回收机制

浏览器垃圾回收机制是一种自动管理内存机制，用于释放不再被使用的内存，回收系统资源、减少内存泄漏风险。

常用的垃圾回收方式有两种：**标记清除**、**引用计数**

1. 标记清除

   标记清除算法主要分为两个阶段：标记阶段和清除阶段。在标记阶段，垃圾回收器会从根对象开始遍历所有对象，标记可以被访问的对象。在清除阶段，清除没有被标记的对象。这些对象被认为是不可访问的，可以被安全回收。

2. 引用计数

   引用计数是跟踪记录每个对象被引用的次数，当计数为0时，表示该对象不再被使用，可以被回收。

#### Vue

##### 1.为什么data属性是一个函数而不是一个对象？

*vue*组件可能会有很多个实例，采用函数返回一个全新的*data*，使得每个实例对象的数据不会受到其他实例对象数据的污染。

而根组件是*vue*的实例，不会被复用，所以*data*可以是一个对象。

##### 2. v-show 和 v-if 有什么区别？

*v-if* 和 *v-show* 都能控制 *dom*元素在页面的显示

*v-if* 是条件渲染，确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。

*v-show* 不管初始条件，元素总是被渲染，基于*css*的*display*属性进行切换。

由于 *v-if* 开销比 *v-show* 更大，在需要频繁切换时使用*v-show* 更好。

##### 3.vue是怎么实现双向绑定的？

（说定义）

*vue*中的数据双向绑定指的是：数据变化更新视图，视图改变更新数据。

*vue*2 实现步骤：

1. 在 *Observe* 中执行 *new Vue()* 初始化，对*data* 执行响应化处理
2. 同时在 *Compile* 中对模版进行编译，找到动态绑定的数据，从 *data* 中获取并初始化视图
3. 同时定义一个更新函数和 *Watcher* ，将来对应数据变化时 *Watcher* 会调用更新函数
4. 由于 *data* 的某个 *key* 在一个视图中可能会出现多次，所以每个 *key* 都需要一个管家 *Dep* 来管理多个 *Watcher*
5. 将来 *data* 中数据一旦发生变化，会首先找到对应的 *Dep* ，通知所有 *Watcher* 执行更新函数

![双向绑定](/Users/lingziya/Desktop/学习/双向绑定.png)



**依赖收集**

在视图中会用到 *data* 中某个 *key* ，这是**依赖**。同一个 *key*可能出现多次，每次都需要收集，用一个 *Watcher* 来维护，这一过程就是**依赖收集**

多个 *Watcher* 需要一个 *Dep* 进行管理，需要更新时由 *Dep* 统一通知。

![依赖收集](/Users/lingziya/Desktop/学习/依赖收集.png)

1. *defineReactive* 为每一个 *key* 创建一个 *Dep* 实例
2. 初始化视图时读取某个 *key*1 ，创建对应的一个 *watcher*1 
3. 触发 *key*1 的 *getter* 方法，将 *watcher*1 添加到 *key*1 对应的 *Dep* 中
4. 当 *key*1 更新，*setter* 触发时，可通过对应 *Dep* 通知其管理所有 *Watcher* 更新

##### 4.nextTick有什么作用？

（说定义）

在下次 *DOM*更新循环结束后执行延迟回调。在修改数据后立即使用这个方法，获取更新后的*DOM*

(使用场景)

想要在修改数据后立即得到更新后的*DOM*结构时使用

`function nextTick(callback?: () => void): Promise<void>`

传递一个回调函数作为参数，或*await*返回的*Promise*

##### 5.说下slot的用法

（定义）

插槽是组件内的一个占位符，该占位符可以使用自己的标记语言进行填充。

1. 默认插槽

   - 子组件用`<slot>`标签确定渲染的位置，当父组件使用的时候，会将子组件中`<slot>`标签之间的内容作为默认内容渲染。

2. 具名插槽

   - 子组件用*name*属性表示插槽的名字，不传为默认插槽
   - 父组件在使用时加上*slot*属性，值为子组件插槽*name*属性值

   子组件

   ```vue
   <template>
     <slot name="content">插槽后备的内容</slot>
   </template>		
   ```

   父组件

   ```vue
   <child>
       <template v-slot:default>具名插槽</template>
       <!-- 具名插槽⽤插槽名做参数 -->
       <template v-slot:content>内容...</template>
   </child>
   ```

3. 作用域插槽

   子组件在作用域上绑定属性来将子组件的信息传给父组件使用，这些属性会被挂在父组件*v-shot*接受的对象上

   - 父组件这种在使用时通过*v-shot*（简写：#）获取子组件的信息，在内容中使用

   子组件

   ```vue
   <template> 
     <slot name="footer" testProps="子组件的值">
             <h3>没传footer插槽</h3>
       </slot>
   </template>
   ```

   父组件

   ```vue
   <child> 
       <!-- 把v-slot的值指定为作⽤域上下⽂对象 -->
       <template v-slot:default="slotProps">
         来⾃⼦组件数据：{{slotProps.testProps}}
       </template>
       <template #default="slotProps">
         来⾃⼦组件数据：{{slotProps.testProps}}
       </template>
   </child>
   ```

- *v-shot*属性只能在`<template>`上使用
- 默认插槽名为*default*，可以省略*default*直接写*v-shot*
- 缩写为 # 时必须写参数，写成 #*default*

（使用场景）

父组件在使用到一个复用组件的时候，获取这个组件在不同的地方有少量的更改，通过*slot*插槽向组件内部指定位置传递内容，完成这个组件在不同场景的应用。

布局组件、表格列、下拉项、弹框显示内容。

##### 6.Vue中key的作用？

*key*的作用主要是为了更加高效地更新虚拟*DOM*

*Vue*判断两个节点是否相同时，主要是通过两者的*key*和元素类型*tag*。如果不设置*key*，它的值就是*undefined*，可能被认为是相同节点，只能进行更新操作，进行大量的*DOM*更新操作。

##### 7.Composition API 和 Options API的区别？

*Vue*2使用*option API*，通过定义一个*options*对象进行组件的配置，包括*props*、*data*、*methods*等属性和方法，共同处理页面逻辑。这种方法结构清晰，在小项目中易于理解，当组件变得复杂时，会变得难以阅读和理解。

*Vue*3使用*composition API*，组件代码通过函数形式进行编写，一个功能定义的所有*API*会放在一起（高内聚、低耦合），能更好实现组件复用，支持类型推断，可拓展性更好。

- 逻辑组织和组件复用，*composition API* 优于 *option API*
- *composition API* 几乎是函数，类型推断更好
- *composition API* 对 *tree-shaking* 友好，代码更容易压缩
- *composition API* 见不到 *this* 的使用，减少了 *this* 指向不明的问题
- 对于小型项目 *option API*更简单方便

##### 8.script setup是什么？

*script setup*是*vue*3的语法糖，简化了组合式*API*的写法，有更好的运行性能。

- 属性和方法无需返回，可以直接使用
- 引入组件的时候，会自动注册，无需通过*components*手动注册
- 使用*defineProps* 接收父组件传递的值
- *useAttrs*获取属性，*useSlots*获取插槽，*defineEmits*获取自定义事件
- 默认不会对外暴露属性，有需要可以使用*defineExpose*

##### 9.什么是Teleport组件？

（说定义）

*Teleport*是Vue3新增的一个组件，可以将组件的*DOM*插到指定的组件层。

*Teleport*组件可以传递两个属性：

- *to*（必须）：指定组件需要挂载到*DOM*节点的*ID*
- *disabled*（可选）：一个标志位指示此节点是否应该被瞬移到目标中

（应用场景）

实现一些弹出框、提示框等组件功能。

##### 10.Vue怎么做权限管理？

（说定义）

权限管理是确保用户只能访问到被分配的资源。

对前端权限，一般是**页面权限**和**按钮权限**，对于这两方面进行控制，实现：

1. 路由方面，用户登陆后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址
2. 视图方面，用户只能看到自己有权浏览的内容和有权操作的控件
3. 若是路由配置失误，按钮权限遗忘，利用请求控制做最后保障，越权请求将在前端被拦截

**接口权限**

接口权限一般采用*jwt*的形式验证，没有的返回401，跳转登录页面进行重新登录，登录完拿到*token*，将*token*存储，通过*axios*请求拦截器进行拦截，每次请求的时候头部携带*token*

```js
axios.interceptors.request.use(config => {
    config.headers['token'] = cookie.get('token')
    return config
})
axios.interceptors.response.use(res=>{},{response}=>{
    if (response.data.code === 40099 || response.data.code === 40098) { //token过期或者错误
        router.push('/login')
    }
})
```

**路由权限**

- 初始化时挂载全部路由，在路由上标记相应的权限信息，每次跳转前做校验

```js
const routerMap = [
  {
    path: '/permission',
    component: Layout,
    redirect: '/permission/index',
    alwaysShow: true, // will always show the root menu
    meta: {
      title: 'permission',
      icon: 'lock',
      roles: ['admin', 'editor'] // you can set roles in root nav
    },
    children: [{
      path: 'page',
      component: () => import('@/views/permission/page'),
      name: 'pagePermission',
      meta: {
        title: 'pagePermission',
        roles: ['admin'] // or you can only set roles in sub nav
      }
    }, {
      path: 'directive',
      component: () => import('@/views/permission/directive'),
      name: 'directivePermission',
      meta: {
        title: 'directivePermission'
        // if do not set roles, means: this page does not require permission
      }
    }]
  }]
```

- 初始化时先挂载不需要权限控制的路由，登录后获取用的权限信息，然后筛选有权访问的路由，在全局路由守卫里调用*addRoutes*添加路由

```js
import router from './router'
import store from './store'
import { Message } from 'element-ui'
import NProgress from 'nprogress' // progress bar
import 'nprogress/nprogress.css'// progress bar style
import { getToken } from '@/utils/auth' // getToken from cookie

NProgress.configure({ showSpinner: false })// NProgress Configuration

// permission judge function
function hasPermission(roles, permissionRoles) {
  if (roles.indexOf('admin') >= 0) return true // admin permission passed directly
  if (!permissionRoles) return true
  return roles.some(role => permissionRoles.indexOf(role) >= 0)
}

const whiteList = ['/login', '/authredirect']// no redirect whitelist

router.beforeEach((to, from, next) => {
  NProgress.start() // start progress bar
  if (getToken()) { // determine if there has token
    /* has token*/
    if (to.path === '/login') {
      next({ path: '/' })
      NProgress.done() // if current page is dashboard will not trigger	afterEach hook, so manually handle it
    } else {
      if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息
        store.dispatch('GetUserInfo').then(res => { // 拉取user_info
          const roles = res.data.roles // note: roles must be a array! such as: ['editor','develop']
          store.dispatch('GenerateRoutes', { roles }).then(() => { // 根据roles权限生成可访问的路由表
            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表
            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record
          })
        }).catch((err) => {
          store.dispatch('FedLogOut').then(() => {
            Message.error(err || 'Verification failed, please login again')
            next({ path: '/' })
          })
        })
      } else {
        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓
        if (hasPermission(store.getters.roles, to.meta.roles)) {
          next()//
        } else {
          next({ path: '/401', replace: true, query: { noGoBack: true }})
        }
        // 可删 ↑
      }
    }
  } else {
    /* has no token*/
    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入
      next()
    } else {
      next('/login') // 否则全部重定向到登录页
      NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it
    }
  }
})

router.afterEach(() => {
  NProgress.done() // finish progress bar
})
```

**菜单权限**

将页面与路由进行解耦

- 菜单与路由分离，菜单由后端返回，前端定义路由信息

```js
{
    name: "login",
    path: "/login",
    component: () => import("@/pages/Login.vue")
}
```

*name*字段与后端返回菜单做关联，做唯一性校验

```js
function hasPermission(router, accessMenu) {
  if (whiteList.indexOf(router.path) !== -1) {
    return true;
  }
  let menu = Util.getMenuByName(router.name, accessMenu);
  if (menu.name) {
    return true;
  }
  return false;

}

Router.beforeEach(async (to, from, next) => {
  if (getToken()) {
    let userInfo = store.state.user.userInfo;
    if (!userInfo.name) {
      try {
        await store.dispatch("GetUserInfo")
        await store.dispatch('updateAccessMenu')
        if (to.path === '/login') {
          next({ name: 'home_index' })
        } else {
          //Util.toDefaultPage([...routers], to.name, router, next);
          next({ ...to, replace: true })//菜单权限更新完成,重新进一次当前路由
        }
      }  
      catch (e) {
        if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入
          next()
        } else {
          next('/login')
        }
      }
    } else {
      if (to.path === '/login') {
        next({ name: 'home_index' })
      } else {
        if (hasPermission(to, store.getters.accessMenu)) {
          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);
        } else {
          next({ path: '/403',replace:true })
        }
      }
    }
  } else {
    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入
      next()
    } else {
      next('/login')
    }
  }
  let menu = Util.getMenuByName(to.name, store.getters.accessMenu);
  Util.title(menu.title);
});

Router.afterEach((to) => {
  window.scrollTo(0, 0);
});
```

- 菜单和路由都由后端返回，前端统一定义路由组件

```js
const Home = () => import("../pages/Home.vue");
const UserInfo = () => import("../pages/UserInfo.vue");
export default {
    home: Home,
    userInfo: UserInfo
};
```

```json
[
    {
        name: "home",
        path: "/",
        component: "home"
    },
    {
        name: "home",
        path: "/userinfo",
        component: "userInfo"
    }
]
```

**按钮权限**

通过自定义指令进行按钮权限的判断

自定义权限鉴定指令：

```js
import Vue from 'vue'
/**权限指令**/
const has = Vue.directive('has', {
    bind: function (el, binding, vnode) {
        // 获取页面按钮权限
        let btnPermissionsArr = [];
        if(binding.value){
            // 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。
            btnPermissionsArr = Array.of(binding.value);
        }else{
            // 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。
            btnPermissionsArr = vnode.context.$route.meta.btnPermissions;
        }
        if (!Vue.prototype.$_has(btnPermissionsArr)) {
            el.parentNode.removeChild(el);
        }
    }
});
// 权限检查方法
Vue.prototype.$_has = function (value) {
    let isExist = false;
    // 获取用户按钮权限
    let btnPermissionsStr = sessionStorage.getItem("btnPermissions");
    if (btnPermissionsStr == undefined || btnPermissionsStr == null) {
        return false;
    }
    if (value.indexOf(btnPermissionsStr) > -1) {
        isExist = true;
    }
    return isExist;
};
export {has}
```

在使用的按钮中只需要引用`v-has`指令：

```js
<el-button @click='editClick' type="primary" v-has>编辑</el-button>
```

##### 11.怎么定义动态路由？

（说定义）

在实际开发中，需要将给定匹配模式的路由映射到同一个组件，这就需要定义一个动态路由。在路径中使用一个动态字段来实现。

路径参数用冒号 **：**表示，当一个路由被匹配时，它的*params*值将在每个组件中以 *this.$route.params*的形式暴露出来。

##### 12.Vue实例挂载的过程中发生了什么？

挂载过程指的是app.mount()过程，这个过程整体上做了两件事：初始化和建立更新机制

初始化的过程会创建组件实例、初始化组件状态，创建各种响应式数据

建立更新机制这一步会立即执行一次组件更新函数，这会首次执行组件渲染函数并执行*patch*将前面获得的*node*转换为*dom*，同时首次执行渲染函数会创建它内部响应式数据之间和组件更新函数之间的依赖关系，这使得之后数据变化时会执行对应的更新函数。

##### 12.ref和reactive的区别？

（说定义）

*ref*接受内部值，返回一个响应式、可更改的*Ref*对象--常用于处理单值的响应式

*reactive*返回一个对象的响应式代理--用于处理对象类型的数据响应式

- *ref*返回的响应式数据使用需要加上.*value*才能访问值
- *reactive*内部如果接受*Ref*对象会自动脱*ref*，使用...解构*reactive*返回的响应式对象会使其失去响应式，可以结合*toRefs()*将值转换为*Ref*对象

##### 13.watch和watchEffect的区别？

（说定义）

*watchEffect()*立即运行一个函数，同时响应式的追踪其依赖，并在依赖更改时重新执行

*watch()*侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数

*watchEffect*可以认为是一种特殊的*watch*,传入的函数既是依赖收集的数据源，也是回调函数。

- *watchEffect*在使用时，传入的函数会立即执行一次。*watch*默认首次不会执行回调函数，除非手动设置*immediate*属性

##### 14.异步组件是什么？

（说定义）

在大型项目中，需要将应用拆分为更小的块，仅在需要时从服务器加载相关组件。

（实现方式）

- *defineAsyncComponent()*方法接收一个返回*Promise*的加载函数，结合*ES*模块动态导入*import*实现。

```vue
// app.vue
<script setup>
import {onMounted, defineAsyncComponent } from 'vue'
import Child from './child.vue'
const AsyncChild = defineAsyncComponent(() => (new Promise((resolve, reject) => resolve(Child))))
onMounted(() => {
    console.log('app')
})
</script>
<template>
    <AsyncChild />
</template>
```

- 不采用动态导入的方式创建可以传入一个特殊对象

```js
const AsyncComp = defineAsyncComponent({
  // 加载函数，需要返回一个Promise，可以使用动态import的方式，也可以自己new Promise()
  loader: () => import('./Foo.vue'),
  // 加载异步组件时使用的组件，该组件会在异步组件加载时显示，如果异步组件加载很快，可能不会出现loading组件
  loadingComponent: LoadingComponent,
  // 展示加载组件前的延迟时间，默认为 200ms
  delay: 200,
  // 加载失败后展示的组件，可以通过Promise的reject来测试
  errorComponent: ErrorComponent,
  // 如果提供了一个 timeout 时间限制，并超时了
  // 也会显示这里配置的报错组件，默认值是：Infinity
  timeout: 3000
})
```

- 异步组件不能被用于定义懒加载路由上，处理它的是*vue*框架，处理路由组件加载的是*vue-router*。但是可以在懒加载的路由组件中使用异步组件。

##### 15.使用vue渲染大量数据的时候应该怎么优化？

- 采取分页的方式获取数据
- *vue-virtual-scroller*等虚拟滚动方案，只渲染视口范围内的数据
- 对于不需要更新的数据，可以使用*v-once*只渲染一次
- 使用*v-memo*缓存结果，结合*v-for*使用，避免数据变化时不必要的*VNode*创建
- 采用懒加载

#####  16. Vue封装了哪些数组方法？

在Vue2中，由于`Object.defineProperty`方法不能监听到数组的内部变化，数组长度变化，所以需要对这些操作进行hack，让Vue能够监听到其中的变化。

Vue将被侦听的数组的变更的方法进行了包裹，使其也能触发视图更新。这些方法有：

- push()
- pop()
- shift()
- unshift()
- splice()
- sort()
- reverse()

##### 17.

#### Webpack

##### 1.说下webpack的构建流程

*webpack*的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来。

主要分为三大过程：

1. 初始化流程：从配置文件和*Shell*语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数
   - 配置文件下默认为*webpack.config.js*，用于激活*webpack*的加载项和插件
   - *webpack*将*webpack.config.js*中的各个配置项拷贝到*options*对象中，并加载用户配置的*plugins*
   - 初始化*Compiler*编译对象
2. 编译构建流程：从*Entry*出发，针对每个*Module*串行调用对应的*Loader*去翻译文件内容，再找到该*Module*依赖的*Module*，递归地进行编译处理
3. 输出流程：对编译后的*Module*组合成*Chunk*，把*Chunk*转换成文件，输出到文件系统

![webpack编译](/Users/lingziya/Desktop/学习/webpack编译.png)

##### 2.webpack的热更新原理？

（说定义）

*HMR*全称*Hot Module Replacement*，指应用程序在运行过程中，替换、添加、删除模块，而无需刷新整个应用。

使用时需要制定哪些模块发生更新时进行*HMR*

```js
const webpack = require('webpack')
module.exports = {
  // ...
  devServer: {
    // 开启 HMR 特性
    hot: true
    // hotOnly: true
  }
}
```

```js
if(module.hot){
    module.hot.accept('./util.js',()=>{
        console.log("util.js更新了")
    })
}
```

(实现原理)

- 通过*webpack-dev-server*创建两个服务器：提供静态资源的服务（*express*）和*Socket*服务
- *express server*负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）
- *socket server*是一个*websocket*的长连接，双方可以通信
- 当*socket server*监听到对应的模块发生变化时，会生成两个文件.*json*（*manifest*文件）和.*js*文件（*update chunk*）
- 通过长连接，*socket server*可以直接将这两个文件主动发送给客户端
- 浏览器拿到两个新的文件后，通过*HMR runtime*机制，记载这两个文件，并针对修改的模块进行更新

##### 3.webpack如何进行tree shaking的？

##### 4. **Loader**和**Plugin**的不同？ 



#### TypeScript

##### 1.解释下typescript中的枚举

（说定义）

枚举是一个被命名的整型常数的集合。当一个变量有几种可能的取值时，可以将它定义为枚举类型。

（说用法）

通过关键字 *enum* 进行定义：

```ts
enum xxx { ... }
// 声明d为枚举类型Dorection
let d: Direction
```

类型可以分为：

- 数字枚举

```ts
// 默认值0开始依次累加
enum Direction {
    Up,   // 值默认为 0
    Down, // 值默认为 1
    Left, // 值默认为 2
    Right // 值默认为 3
}
console.log(Direction.Up === 0); // true
console.log(Direction.Down === 1); // true
// 将第一个值进行赋值后，后面的值也会根据前一个值进行累加1
enum Direction {
    Up = 10,
    Down,
    Left,
    Right
}
console.log(Direction.Up, Direction.Down, Direction.Left, Direction.Right); // 10 11 12 13
```

- 字符串枚举

```ts
// 枚举类型的值其实也可以是字符串类型
enum Direction {
    Up = 'Up',
    Down = 'Down',
    Left = 'Left',
    Right = 'Right'
}
console.log(Direction['Right'], Direction.Up); // Right Up
// 如果设定了一个变量为字符串之后，后续的字段也需要赋值字符串，否则报错
enum Direction {
   Up = 'UP',
   Down, // error TS1061: Enum member must have initializer
   Left, // error TS1061: Enum member must have initializer
   Right // error TS1061: Enum member must have initializer
}
```

- 异构枚举

```ts
// 将数字枚举和字符串枚举结合起来使用
enum BooleanLikeHeterogeneousEnum {
    No = 0,
    Yes = "YES",
}
```

**枚举和常量枚举的区别**：

1. 枚举会被编译成一个对象，*const*枚举会在编译期间被删除，避免额外的性能开销

```ts
// const枚举
const enum Witcher {
  Ciri = 'Queen',
  Geralt = 'Geralt of Rivia'
}
const witchers: Witcher[] = [Witcher.Ciri, Witcher.Geralt]
// 编译后
// const witchers = ['Queen', 'Geralt of Rivia'
```

（应用场景）

对于后端返回的字段使用0-6标记对应的日期，或者返回0-1等状态时，皆可用枚举定义，提高代码可读性

##### 2.TypeScript中的类型断言是什么？

（说定义）

类型断言时一种方式，告诉编辑器某个值的具体类型，允许开发者手动指定变量或表达式的类型。

（说用法）

- 尖括号语法：

```ts
let strLength: number = (<string>someValue).length;
```

- *as*语法：

```ts
let strLength: number = (someValue as string).length;
```

##### 3.TypeScript中的类是什么？

（说定义）

类是一种用户定义的引用数据类型，在*ts*中的类支持面向对象的所有特性。

（说用法）

定义**类**的关键字为*class*，后面紧跟类型：

- 字段：类里面声明的变量，字段表示对象的有关数据
- 构造函数：类是实例化时调用，为类的对象分配内存
- 方法：方法为对象要执行的操作

```ts
class Car {
    // 字段
    engine:string;
    // 构造函数
    constructor(engine:string) {
        this.engine = engine
    }
    // 方法
    disp():void {
        console.log("发动机为 :   "+this.engine)
    }
}
```

**继承是一种从另一个类获取一个类的属性和行为的机制**

*ts*中类的继承通过*extends*关键字实现：

```ts
class Animal {
    move(distanceInMeters: number = 0) {
        console.log(`Animal moved ${distanceInMeters}m.`);
    }
}
class Dog extends Animal {
    bark() {
        console.log('Woof! Woof!');
    }
}

//继承后，子类可以对父类的方法重新定义，通过super关键字引用父类的属性和方法
class PrinterClass {
   doPrint():void {
      console.log("父类的 doPrint() 方法。")
   }
}
class StringPrinter extends PrinterClass {
   doPrint():void {
      super.doPrint() // 调用父类的函数
      console.log("子类的 doPrint()方法。")
   }
}
```

*ts*的继承形式和*ES6*的很相似，但*ts*多了几种**修饰符**：

- *public*：可以自由访问**类**里定义的成员
- *private*：只能够在该**类**内部进行访问，实例对象不行，继承的子类也不行
- *protect*：除了在该**类**的内部可以访问，在子类中也能访问
- *readonly*：只读属性必须在声明时或者构造函数里被初始化
- *static*：用于定义静态属性
- ***abstract***：用于定义抽象类和在抽象类内部定义抽象方法，这种类不能被实例化

（应用场景）

在*React*中，组件需要传入*props*的类型*Props*，因此使用*class*很适合。

```ts
export default class Carousel extends React.Component<Props, State> {}
// props的类型
export default class Props {
  public children: Array<React.ReactElement<any>> | React.ReactElement<any> | never[] = []
  public speed: number = 500
  public animation: string = 'easeInOutQuad'
  public isAuto: boolean = true
  public afterChange: () => {}
}
public static defaultProps = new Props()
```

##### 4.TypeScript中的泛型有什么用？

（说定义）

泛型是在定义函数，接口或者类的时候，不预先 定义好具体的类型，而在使用时候指定类型的一种特性。

（说用法）

在泛型中，类型参数卸载`<>`之间，使其成为强类型集合。

```ts
function returnItem<T>(para: T): T {
    return para
}
```

也可以一次定义多个类型参数：

```ts
function swap<T, U>(tuple: [T, U]): [U, T] {
    return [tuple[1], tuple[0]];
}
swap([7, 'seven']); // ['seven', 7]
```

##### 5.TypeScript中装饰器的作用？

（说定义）

装饰器是一种特殊类型的声明，它能被附加到类声明，方法，属性或参数上，在不改变原类和使用继承的情况下，动态扩展对象功能。

本质上是*Object.defineProperty*的语法糖，也就是一种方法。

可以用于装饰：

- 类

```ts
// 声明一个函数addAge给Class的属性age添加年龄
function addAge(constructor: Function) {
  constructor.prototype.age = 18;
}
@addAge
class Person{
  name: string;
  age!: number;
  constructor() {
    this.name = 'huihui';
  }
}
let person = new Person();
console.log(person.age); // 18
```

- 方法/属性

- 参数
- 访问器装饰

##### 6.TypeScript中never和void的区别？

（说定义）

*void*表示没有任何类型（可以被赋值为*null* 和 *undefined*）

*never*表示一个不包含值的类型，即表示永远不存在的值

拥有 *void* 返回值类型的函数能正常运行。拥有 *never* 返回值类型的函数无法正常返回，无法终止或会抛出异常

##### 7.TypeScript中的interface和type有什么区别？

相同点：

- *interface*和*type*都可以用于描述一个对象或函数

- *interface*和*type*都可以扩展，且可以互相扩展

不同点：

- *type*可以声明基本类型别名，联合类型，元祖类型
- *type*语句可以使用*typeof*获取实例的类型进行赋值
- *interface*能够声明合并，*type*不能定义多次

**一般来说，能用*interface*就用*interface*，不行就用*type***

##### 8. ?.、??、!.等符号的含义？

?. 可选运算符，用于判断左侧表达式是否是*null*或者*undefined*，如果是将停止表达式

?? 空值合并运算符，用于判断左侧表达式是否是*null*或*undefined*，如果是返回右边的值

!.  在变量后添加，断言排除*undefined*和*null*类型

#### React

##### 1.React的核心特性是什么？

使用虚拟*Dom*来操作*DOM*，遵循从高阶组件到低阶组件的单向数据流，帮助我们将界面分成各个独立的小块，每个小块就是一个组件，这些组件之间可以组合、嵌套，构成整体页面。

特性：*JSX*语法、单项数据流绑定、虚拟*DOM*、声明式编程、*Component*

- 声明式编程

声明式编程是一种范式，表达逻辑而不显式地定义步骤，根据逻辑计算来声明要显示的组件。

- *Component*

在*React*中，一切皆为组件。组件可以是一个函数或着一个类，接受数据输入，处理它并返回在*UI*中呈现的*React*元素。

```jsx
//函数式组件
const Header = () => {
  return (
    <Jumbotron style={{ backgroundColor: "orange" }}>
      <h1>TODO App</h1>
    </Jumbotron>
  );
};
```

```jsx
//类组件
class Dashboard extends React.Component {
  constructor(props) {
    super(props);

    this.state = {};
  }
  render() {
    return (
      <div className="dashboard">
        <ToDoForm />
        <ToDolist />
      </div>
    );
  }
}
```

##### 2.React的生命周期有哪些阶段？

*React*的生命周期有三个阶段：

1. 创建阶段
   - *construtor*：定义状态，存放一些*this*的方法
   - *getDerivedStateFormProps()*：将来会使用的，需要返回一个新的对象作为一个新的*state*或者返回*null*表示*state*状态不需要更新
   - *render()*：类组件必须实现的方法，用于渲染*DOM*结构，可以访问组件*state*与*prop*属性
   - *componentDidMount()*：用于执行一些数据获取，事件监听等
2. 更新阶段
   - *getDerivedStateFormProps()*：将来会使用的，需要返回一个新的对象作为一个新的*state*或者返回*null*表示*state*状态不需要更新
   - *shouldComponentUpdate()*：用于告知组件本身基本当前的*props*和*state*是否需要重新渲染组件，默认情况返回*true*
   - *render()*：类组件必须实现的方法，用于渲染*DOM*结构，可以访问组件*state*和*prop*属性
   - *getShnapshotBeforeUpdate()*：该周期函数在*render*后执行，执行之时*DOM*元素还没有被更新，目的在于获取组件更新前的一些信息，在组件更新后可以根据这些信息恢复一些*UI*视觉上的状态
   - *componentDidUpdate()*：可以根据前后的*props*和*state*的变化做相应的操作
3. 卸载阶段
   - *componentWillUnmount()*：此方法用于组件卸载前，清理一些注册监听事件，或者取消订阅的网络请求等，一旦一个组件实例被卸载，不会被再次挂载，只能被重新创建

##### 3.React中的hooks有什么用？

（说定义）

*hooks*是一种可以在不编写*class*的情况下使用*state*的特性。

最常用的*hooks*：

*useState*：跟组件中的*state*类似，方便我们定义初始化的数据，接受两个参数，一个是初始化数据，另一个是修改数据的方法

*useEffect*：副作用函数，只有使用之后才会产生副作用，接受两个参数，一个是函数，另一个是要监听的数据

*useMemo*：数据缓存，当我们进行组件通信时，组件数据会进行更新，利用这个勾子可以减少不必要的更新操作，缓存的参数是一个字符串，如果是一个函数的话，*useMemo*会失效，此时应使用*useCallback*进行数据的缓存操作

*useRef*：可以监听输入框数据的变化，获取输入框中的值

##### 4.React中组件的通信方式

- 父组件向子组件传递

父组件在调用子组件的时候，只需要在子组件标签页内传递参数，子组件通过*props*属性就能接收父组件传递的参数

```jsx
function EmailInput(props) {
  return (
    <label>
      Email: <input value={props.email} />
    </label>
  );
}

const element = <EmailInput email="123124132@163.com" />;
```

- 子组件向父组件传递

父组件向子组件传一个函数，然后通过这个函数的回调，拿到子组件传过来的值

- 兄弟组件之间传递

父组件作为中间层来实现数据的互通，通过使用父组件传递

```jsx
class Parent extends React.Component {
  constructor(props) {
    super(props)
    this.state = {count: 0}
  }
  setCount = () => {
    this.setState({count: this.state.count + 1})
  }
  render() {
    return (
      <div>
        <SiblingA count={this.state.count} />
        <SiblingB onClick={this.setCount} />
      </div>
    );
  }
}
```

- 父组件向后代组件传递

使用*context*提供了组件之间通讯的一种方式，可以共享数据，其他数据都能读取到对应的数据。

```jsx
// 创建context 
const PriceContext = React.createContext('price')
```

*Provider*组件创建数据，*Consumer*组件接收数据

```jsx
<PriceContext.Provider value={100}> </PriceContext.Provider>
```

```jsx
<PriceContext.Consumer>
    { /*这里是一个函数*/ }
    {
        price => <div>price：{price}</div>
    }
</PriceContext.Consumer>
```

- 非关系组件传递

将数据进行一个全局资源管理。如使用*Redux*进行通信。

##### 5.React jsx 转换成真实DOM的过程

1. 使用*React.createElement*或*jsx*编写*react*组件，实际上所有的*jsx*代码最后都会转换成*React.createElement(...)*，*babel*帮助我们完成转换的过程
2. *createElement*函数对于*key*和*ref*等特殊的*props*进行处理，并获取*defaultProps*对默认的*props*进行赋值，并且对传入的子节点进行处理，最终构成一个虚拟*DOM*对象
3. *ReactDOM.render*将生成好的虚拟*DOM*渲染到指定的容器上，采用了批处理，事务等机制并且对特定的浏览器进行了性能优化，最终转换成真实*DOM*

##### 6.受控组件和非受控组件有什么区别？

（说定义）

受控组件：受到*setState*的控制，组件状态全程响应外部数据

非受控组件：数据由*DOM*本身处理，一般在初始化的时候接收外部的数据，然后在内部存储自身的状态

（应用场景）

受控组件：强势输入格式、一个数据的多个输入、动态输入、表单验证问题

非受控组件：一次性取值（提交时）、提交时验证

